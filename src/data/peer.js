const FileSystemPromises = require('fs').promises

const BaseN = require('../fn.base.n')
const Try = require('../fn.try.catch')
const TryAsync = require('../fn.try.catch.async')

const __ = require('../const')
const ECDHKey = require('./key.ecdh')
const SymmetricKey = require('./key.symmetric')

/** Peer Object, used for referencing peer */
const Peer = class {
    /** @type {boolean} This is 'Peer' object */
    isPeer = true

    /** @type {string} IP Address*/
    ip = ''

    /** @type {number} Last accessed time*/
    lastAccess = 0

    /** @type {number} Peer connected port*/
    port = 8080

    /** @type {Buffer} Peer public key.*/
    pub = Buffer.from([])

    /** @type {boolean} Is this peer connected to us */
    isSender = false

    /** @type {boolean} Keep alive client polling timer? */
    keepAlive = false

    /** @type {Buffer} Randomly generated public key to be shared with another peer*/
    myPub = Buffer.from([])

    /** @type {boolean} Is this a public peer? (directly accessible)*/
    public = false

    /** @type {SymmetricKey} Peer Symmetric key*/
    key

    /** @type {function} Some of function to be put for special purposes */
    callback

    /** @type {number} Peer quality indicator*/
    quality = __.MAX_TRIAL

    /** @type {FileSystemPromises.FileHandle} Current file open, generated by FileSystem.open(), -1 means not active*/
    mediaStream = -1

    /** @type {Buffer} Hash of current media stream*/
    mediaStreamHash = undefined

    /** @type {string} Location of media stream*/
    mediaStreamLocation = ''

    /** @type {string} Amount of bytes received */
    mediaStreamPacketsReceived = 0

    /** @type {string} Number of total packets that will be received*/
    mediaStreamPacketsTotal = 0

    /** @type {number} Previous byte position */
    mediaStreamPreviousPacket = 0

    /** @type {Object[]} List of media streams in queue*/
    mediaStreamQueue = []

    /** @type {function} Peer callback to be used when sending large bytes*/
    mediaStreamCb

    /**
     * Check if this peer has a connection
     */
    connected () {
        return this.keepAlive
    }

    /**
     * Close media stream
     */
    async closeMediaStream () {
        return await TryAsync(async () => {
            this.mediaStreamLocation = ''
            this.mediaStreamHash = undefined
            this.mediaStreamPacketsTotal = 0
            this.mediaStreamPacketsReceived = 0

            if (typeof this.mediaStream !== 'undefined') {
                await this.mediaStream.close()
                this.mediaStream = undefined
            }
        })
    }

    /**
     * Get current hash value for media stream
     * @returns {string}
     */
    getMediaStreamHash () {
        return BaseN.encode(this.mediaStreamHash, '92')
    }

    /**
     * Get temporary media stream file location
     * @returns {string}
     */
    getMediaStreamTempLocation () {
        return `./data/temp.${this.ip}_${this.port}`        
    }

    /**
     * Open media stream
     * @param {string} location Location to start media stream
     * @param {string} hash Hash to be used for verifying
     * @param {number} packetsNumber Number of packets
     */
    async openMediaStream (location, hash, packetsNumber) {
        return await TryAsync(async () => {
            this.mediaStream = await FileSystemPromises.open(this.getMediaStreamTempLocation(), 'w')
            this.mediaStreamHash = BaseN.decode(hash, '92')
            this.mediaStreamLocation = `./data/${location}`
            this.mediaStreamPacketsTotal = packetsNumber
        })
    }

    /**
     * Export to array
     * @returns {Array}
     */
    export () {
        return [
            this.ip,
            this.port,
            this.pub.toString('base64'),
            this.public,
            this.lastAccess,
        ]
    }

    /**
     * Set target's public key
     * @param {Buffer|string} pub Public key (Buffer or base64)
     */
    setPeerPub (pub) {
        if (typeof pub === 'string') {
            if (Try(() => pub = Buffer.from(pub, 'base64'), this.pub))
                return
        }

        if (!Buffer.isBuffer(pub))
            return

        let newECDH = new ECDHKey()

        this.key = newECDH.computeSecret(pub)
        this.myPub = newECDH.getPub()
        this.pub = pub
    }

    /**
     * Create Peer
     * @param {Array} d Array to be imported
     */
    constructor (d) {
        if (!Array.isArray(d))
            return

        if (typeof d[0] === 'string')
            this.ip = d[0]

        if (typeof d[1] === 'number')
            this.port = d[1]

        this.setPeerPub(d[2])

        if (typeof d[3] === 'boolean')
            this.public = d[3]

        if (typeof d[4] === 'number')
            this.lastAccess = d[4]

    }
}

module.exports = Peer